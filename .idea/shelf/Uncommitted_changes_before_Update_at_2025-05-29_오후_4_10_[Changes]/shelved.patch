Index: 2025.05/Longest Substring Without Repeating Characters.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/2025.05/Longest Substring Without Repeating Characters.py b/2025.05/Longest Substring Without Repeating Characters.py
new file mode 100644
--- /dev/null	(date 1748489182724)
+++ b/2025.05/Longest Substring Without Repeating Characters.py	(date 1748489182724)
@@ -0,0 +1,23 @@
+from collections import deque
+
+
+def lengthOfLongestSubstring(s: str) -> int:
+    now_queue = deque()
+    char_set = set()
+    result = 0
+
+    for char in s:
+        if char in char_set:
+            while now_queue[0] != char:
+                removed = now_queue.popleft()
+                char_set.remove(removed)
+            now_queue.popleft()
+            now_queue.append(char)
+        else:
+            now_queue.append(char)
+            char_set.add(char)
+
+        result = max(result, len(char_set))
+    return result
+
+lengthOfLongestSubstring("abcabcbb")
\ No newline at end of file
Index: 2025.05/Reverse Integer.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/2025.05/Reverse Integer.py b/2025.05/Reverse Integer.py
new file mode 100644
--- /dev/null	(date 1748491868900)
+++ b/2025.05/Reverse Integer.py	(date 1748491868900)
@@ -0,0 +1,26 @@
+import math
+from collections import deque
+
+
+def reverse(x: int) -> int:
+    is_minus = x < 0
+    result = 0
+    x = abs(x)
+    while x:
+        x, mod = divmod(x, 10)
+        result = result * 10 + mod
+
+    result = result * -1 if is_minus else result
+
+    if result > 2 ** 31 - 1 or result < -1 * (2 ** 31):
+        result = 0
+
+    return result
+
+
+# print(reverse(8463847412))
+print(reverse(-8463847412))
+# print(reverse(7463847412))
+# print(reverse(0))
+
+# print(2**31)
\ No newline at end of file
Index: 2025.05/String to Integer.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/2025.05/String to Integer.py b/2025.05/String to Integer.py
new file mode 100644
--- /dev/null	(date 1748497869501)
+++ b/2025.05/String to Integer.py	(date 1748497869501)
@@ -0,0 +1,36 @@
+from collections import deque
+
+
+def myAtoi(s: str) -> int:
+    result = 0
+    queue = deque(list(s))
+    print(queue)
+
+    while queue and queue[0] == ' ':
+        queue.popleft()
+
+    negative = False
+    if queue and (queue[0] == '-' or queue[0] == '+'):
+        now = queue.popleft()
+        negative = True if now == '-' else False
+
+    while queue and result == 0 and queue[0] == '0':
+        queue.popleft()
+
+    while queue and queue[0].isdigit():
+        now = queue.popleft()
+        result = result * 10 + int(now)
+
+        if not negative:
+            if result > 2 ** 31 - 1:
+                return 2 ** 31 - 1
+        else:
+            if result > 2 ** 31:
+                return - 2 ** 31
+
+    result = result if not negative else -1 * result
+
+    return result
+
+
+print(myAtoi('-+12'))
Index: 2025.05/Palindrome Number.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/2025.05/Palindrome Number.py b/2025.05/Palindrome Number.py
new file mode 100644
--- /dev/null	(date 1748501350136)
+++ b/2025.05/Palindrome Number.py	(date 1748501350136)
@@ -0,0 +1,19 @@
+import math
+from collections import deque
+
+
+def isPalindrome(x: int) -> bool:
+    if x < 0:
+        return False
+
+    deq = deque()
+    while x > 0:
+        deq.appendleft(x % 10)
+        x = x // 10
+
+    while len(deq) > 1:
+        pre, post = deq.popleft(), deq.pop()
+        if pre != post:
+            return False
+
+    return True
\ No newline at end of file
Index: 2025.05/ATM.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/2025.05/ATM.py b/2025.05/ATM.py
new file mode 100644
--- /dev/null	(date 1747201416890)
+++ b/2025.05/ATM.py	(date 1747201416890)
@@ -0,0 +1,12 @@
+n = int(input())
+arr = list(map(int, input().split()))
+arr.sort()
+
+pre_sum, now_sum, result =0,0,0
+
+for item in arr:
+    now_sum = pre_sum + item
+    pre_sum = now_sum
+    result += now_sum
+
+print(result)
\ No newline at end of file
Index: 2025.05/1,2,3 더하기.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/2025.05/1,2,3 더하기.py b/2025.05/1,2,3 더하기.py
new file mode 100644
--- /dev/null	(date 1747206534839)
+++ b/2025.05/1,2,3 더하기.py	(date 1747206534839)
@@ -0,0 +1,12 @@
+T = int(input())
+arr = []
+for _ in range(T):
+    arr.append(int(input()))
+
+dp = [0, 1, 2, 4, 7]
+
+for i in range(5, 11):
+    dp.append(dp[i - 1] + dp[i - 2] + dp[i - 3])
+
+for item in arr:
+    print(dp[item])
Index: 2025.05/두 수 더하기.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/2025.05/두 수 더하기.py b/2025.05/두 수 더하기.py
new file mode 100644
--- /dev/null	(date 1748439739621)
+++ b/2025.05/두 수 더하기.py	(date 1748439739621)
@@ -0,0 +1,41 @@
+# Definition for singly-linked list.
+class ListNode:
+    def __init__(self, val=0, next=None):
+        self.val = val
+        self.next = next
+
+    def __str__(self):
+        return f"now: {self.val}, next: {self.next}"
+
+
+from typing import Optional
+
+
+def addTwoNumbers(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
+    result = ListNode(0)
+    now = result
+    rest = 0
+
+    while l1 or l2:
+        val1 = l1.val if l1 else 0
+        val2 = l2.val if l2 else 0
+
+        sum_result = val1 + val2 + rest
+        rest = sum_result // 10
+
+        now.next = ListNode(sum_result % 10)
+        now = now.next
+
+        l1 = l1.next if l1 else None
+        l2 = l2.next if l2 else None
+
+        if l1 is None and l2 is None and rest == 1:
+            now.next = ListNode(1)
+
+    return result.next
+
+
+# print(addTwoNumbers(l1=ListNode(2, ListNode(4, ListNode(3))), l2=ListNode(5, ListNode(6, ListNode(4)))))
+# addTwoNumbers(l1=ListNode(0), l2=ListNode(0))
+print(addTwoNumbers(l1=ListNode(9, ListNode(9, ListNode(9, ListNode(9, ListNode(9, ListNode(9, ListNode(9))))))),
+              l2=ListNode(9, ListNode(9, ListNode(9, ListNode(9))))))
